#!/usr/bin/env bash
#
#                  Caddy Installer Script
#
#   Homepage: https://caddyserver.com
#   Issues:   https://github.com/caddyserver/getcaddy.com/issues
#   Requires: bash, curl or wget, tar or unzip
#
# Hello! This is an experimental script that installs Caddy
# into your PATH (which may require password authorization).
# Use it like this:
#
#	$ curl https://getcaddy.com | bash
#	 or
#	$ wget -qO- https://getcaddy.com | bash
#
# In automated environments, you may want to run as root.
# If using curl, we recommend using the -fsSL flags.
#
# If you want to get Caddy with extra features, use -s with a
# comma-separated list of directives, like this:
#
#	$ curl https://getcaddy.com | bash -s git,mailout
#
# Or it can be first downloaded and then run:
#
#	$ wget getcaddy.com -O getcaddy.sh
#	$ bash getcaddy.sh git,mailout
#
# The full list of available features is:
#  DNS,awslambda,cors,expires,filemanager,filter,git,hugo,ipfilter,jsonp,jwt,
#  locale,mailout,minify,multipass,prometheus,ratelimit,realip,search,upload,
#  cloudflare,digitalocean,dnsimple,dyn,gandi,googlecloud,linode,namecheap,ovh,
#  rfc2136,route53,vultr
# (see https://caddyserver.com/download)
#
# When the feature list starts with a comma, the plugins listed after are
# added to the existing binary's present http features. A sole comma means
# keep the same feature set.
#
#	$ wget -qO- getcaddy.com | bash -s ,hugo
#
# It is also valid to just specify 'none' for no plugins.
#
# A forced install location (path+filename) can be given as a second argument:
#
#	$ bash getcaddy.sh none /root/caddyserver
#
# This should work on Mac, Linux, and BSD systems, and
# hopefully Windows with Cygwin. Please open an issue if
# you notice any bugs.
#

install_caddy()
{
	set -E
	trap 'echo -e "Aborted, error $? in command: $BASH_COMMAND"; trap ERR; return 1' ERR

	#########################
	# Which OS and version? #
	#########################

	# Determine arch (and arm)
	# NOTE: `uname -m` is more accurate and universal than `arch`
	# See https://en.wikipedia.org/wiki/Uname
	caddy_arm=""
	unamem="$(uname -m)"
	if [[ $unamem == *aarch64* ]]; then
		caddy_arch="arm64"
	elif [[ $unamem == *64* ]]; then
		caddy_arch="amd64"
	elif [[ $unamem == *86* ]]; then
		caddy_arch="386"
	elif [[ $unamem == *armv5* ]]; then
		caddy_arch="arm"
		caddy_arm="5"
	elif [[ $unamem == *armv6l* ]]; then
		caddy_arch="arm"
		caddy_arm="6"
	elif [[ $unamem == *armv7l* ]]; then
		caddy_arch="arm"
		caddy_arm="7"
	else
		echo "Aborted, unsupported or unknown architecture: $unamem"
		return 2
	fi

	# Determine os, binary name and package type
	caddy_bin="caddy"
	caddy_dl_ext=".tar.gz"
	uname="$(uname)"
	unameu=$(sed 's/./\U&/g' <<<"$uname")
	if [[ ${unameu} == *DARWIN* ]]; then
		caddy_os="darwin"
		caddy_dl_ext=".zip"
		OSX_VER="$(sw_vers | grep ProductVersion | cut -d':' -f2 | cut -f2)"
		IFS='.' read OSX_MAJOR OSX_MINOR _ <<<"$OSX_VER"

		# Major
		if ((OSX_MAJOR < 10)); then
			echo "Aborted, unsupported OS X version (9-)"
			return 3
		fi
		if ((OSX_MAJOR > 10)); then
			echo "Aborted, unsupported OS X version (11+)"
			return 4
		fi

		# Minor
		if ((OSX_MINOR < 5)); then
			echo "Aborted, unsupported OS X version (10.5-)"
			return 5
		fi
	elif [[ ${unameu} == *LINUX* ]]; then
		caddy_os="linux"
	elif [[ ${unameu} == *FREEBSD* ]]; then
		caddy_os="freebsd"
	elif [[ ${unameu} == *OPENBSD* ]]; then
		caddy_os="openbsd"
	elif [[ ${unameu} == *WIN* ]]; then
		# Should catch cygwin
		caddy_os="windows"
		caddy_dl_ext=".zip"
		caddy_bin=$caddy_bin.exe
	else
		echo "Aborted, unsupported or unknown os: $uname"
		return 6
	fi

	# determine install location, caddy_path is the full path
	pid=$(pgrep -nx "$caddy_bin" || true)  # most recent match if running
	if [[ $2 ]]; then  # if specified: force that install location
		caddy_path="$2"
		[[ ${caddy_path:0:1} = / ]] || caddy_path="./$caddy_path"
	elif [[ $pid ]]; then  # if running: use location of the binary
		bin=$(ls -l /proc/$pid/exe)
		caddy_path=$(sed "s@^.* /proc/$pid/exe -> @@" <<<"$bin")
	else
		caddy_path=$(type -p "$caddy_bin" || true)  # use the first caddy binary in PATH
	fi

	###################
	# Which features? #
	###################

	features=$1
	[[ $features = none ]] && features=""
	valid_features=",DNS,awslambda,cors,expires,filemanager,filter,git,hugo,ipfilter,jsonp,jwt,locale,mailout,minify,multipass,prometheus,ratelimit,realip,search,upload,cloudflare,digitalocean,dnsimple,dyn,gandi,googlecloud,linode,namecheap,ovh,rfc2136,route53,vultr,"
	# if features starts with comma: get the current plugins
	if [[ ${features:0:1} = ',' ]]; then
		# if no binary found, just install a new one with the listed features
		if [[ -x $caddy_path ]]; then  # read plugins from binary if present
			plugins=$("$caddy_path" -plugins |grep ' http\.' |sed 's/^.*http\.//')
			# only add valid features in the plugins list
			for plugin in ${plugins[@]}; do
				[[ $valid_features = *,$plugin,* ]] && features+=",$plugin"
			done
		fi
	fi

	# validate the specified features
	featurelist=($(sed 's/,/ /g' <<<"$features"))
	for feature in "${featurelist[@]}"; do
		if [[ $valid_features != *,$feature,* ]]; then
			echo "Aborted, feature '$feature' not valid"
			return 7
		fi
	done
	# remove extraneous commas
	caddy_features=$(sed 's/ /,/g' <<<${featurelist[@]})

	# determine fresh install location
	if [[ -z $caddy_path ]]; then
		install_path="/usr/local/bin"

		# Termux on Android has $PREFIX set which already ends with /usr
		if [[ -n "$ANDROID_ROOT" && -n "$PREFIX" ]]; then
			install_path="$PREFIX/bin"
		fi

		# Fall back to /usr/bin if necessary
		if [[ ! -d $install_path ]]; then
			install_path="/usr/bin"
		fi
		caddy_path="$install_path/$caddy_bin"
	fi

	########################
	# Download and extract #
	########################

	echo "Downloading Caddy for $caddy_os/$caddy_arch..."
	caddy_dl="caddy_${caddy_os}_$caddy_arch${caddy_arm}_custom$caddy_dl_ext"
	caddy_url="https://caddyserver.com/download/build?os=$caddy_os&arch=$caddy_arch&arm=$caddy_arm&features=$caddy_features"
	echo "$caddy_url"

	# Use $PREFIX for compatibility with Termux on Android
	tmp="$PREFIX/tmp"
	# Make room for the download of the package
	rm -rf "$tmp/$caddy_dl"

	if type -p curl &>/dev/null; then
		curl -fsSL "$caddy_url" -o "$tmp/$caddy_dl"
	elif type -p wget &>/dev/null; then
		wget --quiet "$caddy_url" -O "$tmp/$caddy_dl"
	else
		echo "Aborted, could not find curl or wget"
		return 8
	fi

	echo "Extracting..."
	case "$caddy_dl" in
		*.zip)    unzip -o "$tmp/$caddy_dl" "$caddy_bin" -d "$tmp/" ;;
		*.tar.gz) tar -xzf "$tmp/$caddy_dl" -C "$tmp/" "$caddy_bin" ;;
	esac
	chmod +x "$tmp/$caddy_bin"

	# Not every platform has or needs sudo (see issue #40)
	((EUID)) && [[ -z "$ANDROID_ROOT" ]] && sudo_cmd="sudo"

	# Back up existing caddy, if any
	caddy_cur_ver="$("$caddy_path" -version 2>/dev/null | cut -d ' ' -f2)"
	if [[ $caddy_cur_ver ]]; then
		# caddy of some version is already installed
		caddy_backup="${caddy_path}_$caddy_cur_ver"
		echo "Backing up $caddy_path to $caddy_backup"
		echo "(Password may be required.)"
		$sudo_cmd cp -v --backup=numbered "$caddy_path" "$caddy_backup"
	fi

	[[ $pid ]] && echo "Stopping caddy" && kill -SIGINT $pid
	echo "Putting caddy in $caddy_path (may require password)"
	$sudo_cmd mv "$tmp/$caddy_bin" "$caddy_path"
	$sudo_cmd setcap cap_net_bind_service=+ep "$caddy_path"
	[[ $pid ]] && echo "Restarting caddy" && "$caddy_path"
	$sudo_cmd rm "$tmp/$caddy_dl"

	# check installation
	echo "Version: $("$caddy_path" --version)"

	echo "Successfully installed"
	trap ERR
	return 0
}

install_caddy $@
return=$?
((return)) && echo "Not completed, aborted at $return"
